@EXPECTED
Hello
How are you?
1
None
0
0
1
2
3
1
2
3
6
2
3
4
[11, 12, 13, ]
[0, 1, 2, 3, ]
36
Jack
5
@SOURCE
; we can have scope blocks with lambdas :)

fn scope s = s!

val a = 1
scope:
  val a = 10
  io.print "Hello"
  io.print "How are you?"

io.print (conv.toString a)

val b = scope:
  val a = 10

io.print b

; works in functions
fn useScope:
  val a = 10
  scope:
    a = 0
    val c = 1
  io.print a
  ; io.print c - runtime error, c undefined
useScope!

; btw last example can be rewritten
scope:
  val a = 20
  scope:
    a = 0
    val c = 1
  io.print a

val beg = scope
val end = b ; equals to None

; who wants some pascal?
beg:
  io.print 1
  io.print 2
  io.print 3
end


fn foreach s body:
  val i = 0
  val len = seq.len s
  while lt? i len:
    body (seq.get s i)
    i = add i 1

foreach [1, 2, 3] do |x| -> io.print x

fn fold s init body:
  foreach s do |x|:
    init = body init x
  init

fn sum s = fold s 0 add

io.print (sum [1, 2, 3])

fn map s body = fold s [] do |acc x| -> seq.append acc (body x)

foreach (map [1, 2, 3] (add 1)) io.print

io.print (map [1, 2, 3] do |x|:
  add 10 x)

fn cond pred pos neg:
  if cond:
    pos!
  else:
    neg!

fn filter s pred:
  fold s [] do |acc x|:
    if pred x:
      seq.append acc x
    acc

fn flip f a b = f b a

io.print (filter [0, 1, 2, 3, 4, 5, 6] (flip lt? 4))

; classes like in js
fn Person name age:
  {
    getAge: do -> age,
    setAge: do |new|:
      age = new,
    fullInfo: do -> name,
  }

val jack = Person "Jack" 36
io.print jack.getAge!
io.print jack.fullInfo!
jack.setAge 5
io.print jack.getAge!