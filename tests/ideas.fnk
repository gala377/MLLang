@EXPECTED
36
Jack
5
true
5
not even an age
true
11
not integer
@SOURCE
; classes like in js
fn Person name age = {
  fn getAge = age,
  fn setAge new:
    age = new,
  fn fullInfo = name,
}

let jack = Person "Jack" 36
io.print jack.getAge!
io.print jack.fullInfo!
jack.setAge 5
io.print jack.getAge!


fn newtype fields methods:
  let typeid = gensym!
  
  let constr = do vals:
    let passedKeys = map vals fst
    
    foreach fields do field:
      if none? (seq.find passedKeys (eq? field)):
        panic "Not every field has been passed to type constructor"
    foreach vals do fpair:
      if none? (seq.find fields (eq? (fst fpair))):
        panic "Uknown field passed to type constructor"
    
    let this = seq.append vals (`__type__, typeid)
    fold (methods this) this do |this meth|:
      seq.append this (fst meth, snd meth)
    this
  
  {
    typeid,
    new: constr,
  }

let Student = newtype (`age, `name, `surname, `score) do this -> {
  fn getAge = this.age,

  fn setAge age:
    this.age = age,

  fn passes? = lt? 50 this.score,
}

let frank = Student.new {
  name: "Frank",
  surname: "Herbert",
  age: 40,
  score: 51,
}


io.print frank.passes?!
frank.setAge 5

io.print frank.age
frank.age = "not even an age"
io.print frank.getAge!

; runtime error: not every field
; let frank2 = Student.new {
;   surname: "Herbert",
;   age: 40,
;   score: 51,
; }

; runtime error: uknown field
; let frank3 = Student.new {
;   name: "Frank",
;   surname: "Herbert",
;   age: 40,
;   score: 51,
;   middleName: "John",
; }

fn istype? v cons = eq? v.__type__ cons.typeid

io.print (istype? frank Student)

; get filter nonempty strings
assert (seq.eq? (filter ["", "frank", "", "", "goerge"] conv.toBool) ["frank", "goerge"]) "filtering empty strings fails"

fn multimethod selector:
  let meths = []
  {
    fn create = do args:
      let selected = selector args
      let s = seq.get selected 0
      let margs = seq.get selected 1
      let ret = seq.foreach meths do m:
        if (eq? (seq.get m 0) s):
          let impl = seq.get m 1
          let val = apply impl margs
          return (`break, (`found, val))
      if none? ret:
        panic "no multimethod implementation found"
      seq.get ret 1,

    fn instance v m:
      seq.append meths (v, m),
  }

let foom_ = multimethod do args -> [
  int? (seq.get args 0),
  (seq.get args 0, seq.get args 1),
]

let foo = foom_.create!

foom_.instance true do |a b| -> add a b
foom_.instance false do |a b| -> io.print "not integer"

io.print (foo (1, 10))
foo (none, none)
