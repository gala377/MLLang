
let Queue = scope:
  fn new = {
    size: 0,
    beg: none,
    end: none,
  }

  fn empty? q = zero? q.size

  fn pop q:
    if none? q.beg:
      panic "First on empty queue"
    let ret = q.beg.val
    q.beg = q.beg.next
    q.size = dec q.size
    ret

  fn push q val:
    let node = {val, next: none}
    if empty? q:
      q.size = inc q.size
      q.beg = node
      q.end = node
    else:
      q.size = inc q.size
      q.end.next = node
      q.end = node

  fn pushFront q val:
    if empty? q:
      push q val
    else:
      q.size = inc q.size
      q.beg = {
        val, next: q.beg}

  fn fromSeq s:
    let q = new!
    foreach s $ push q
    return q

  { new, empty?, pop, push, pushFront, fromSeq }

let coro = scope:
  effect yield
  effect spawn
  { yield: do -> yield none, spawn, Yield: yield, }

; tasks : Queue of ! -> none [coro.yield]
fn simpleExecutor tasks:
  let push = Queue.push tasks

  let lastSize = none
  while not $ Queue.empty? tasks:
    handle:
      let t = Queue.pop tasks
      t!
    with coro.Yield _ -> k:
      push do -> k none
    with coro.spawn t -> k:
      ; pushFront is necessary here.
      ; earlier versions used
      ; push t
      ; resume k
      ; however because handler in while is not
      ; in tail position even if while is in tail position
      ; we would only reuse handlers frame and not executors
      ; frame which in turn created a stack overflow.
      Queue.pushFront tasks do -> k none
      push t

fn delay seconds:
  let now = time.now!
  while true:
    coro.yield!
    let diff = sub time.now! now
    if lt? seconds diff:
      return

fn task f:
  let future = none
  fn await:
    while none? future:
      coro.yield!
    future.res

  coro.spawn:
    let res = f!
    future = { res }

  await

scope:
  let tasks = Queue.fromSeq [
    do:
      io.print "First task"
      coro.yield!
      io.print "First task continued"
      io.print "This one is not interrupted"
      coro.yield!
      io.print "FT: I think I'll go home now",

    do:
      io.print "Second task"
      io.print "I dont think I'll yield yet"
      coro.yield!
      foreach (seq.range 3) do x:
        io.printf "Second spawning taks %v" x
        coro.spawn:
          io.printf "I am task number %v" x
          delay $ 5 :add x
          io.printf "Spawned task %v reporting from duty" x
      io.print "Second task, I've done my job boss",

    do:
      io.print "Third task"

      let t = task:
        io.print "I was spawned by a third task"
        io.print "I need to do some heavy computation"
        delay 6
        io.print "My heavy computation has been completed"
        io.print "I'll return the result"
        42

      io.print "3rd task. Spawned my heavy comp in the background"
      io.print "I'll sleep for now and then check if it's done"
      delay 5
      io.print "3rd task I am awake now, I'll wait for my computation"
      assert (t! :eq? 42) "Wrong answer"
      io.printf "My answer is %s" t!
      io.print "I got my answer so goodbye for now",
  ]
  simpleExecutor tasks
