
extend seq {
  fn foreach s body:
    let len = seq.len s
    let i = 0
    while lt? i len:
      let ret = (body (seq.get s i))
      if eq? ret `break:
        return
      else if (tuple? ret):
        if eq? `break (fst ret):
          return snd ret
      i = add i 1,

  ; could be optimized to short-circuit
  fn find s pred:
    let res = filter s pred
    if seq.empty? res:
      none
    else:
      fst res,

  fn empty? s = eq? (seq.len s) 0,

  fn notempty? s = not (seq.empty? s),

  ; needs to be anonymous so it does not recurse on itself
  ; when trying to call eq? from prelude
  eq?: do a b:
    if not (eq? (seq.len a) (seq.len b)):
      false
    else:
      fold (zip a b) true do |acc v|:
        if not acc:
          false
        else:
          eq? (fst v) (snd v),

  ; both could be optimized to short-circuit
  and: do -> fold s true and,
  or: do -> fold s false or,
}