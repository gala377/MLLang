fn scope b = b!

let call = scope

fn flip f a b = f b a

fn const a b = a

let const2 = flip const

fn fst s = seq.get s 0

fn snd s = seq.get s 1

fn neq? a b = not (eq? a b)

let inc = add 1

let dec = flip sub 1

let none? = eq? none

let zero? = eq? 0

fn pair? a:
  if tuple? a:
    return eq? 2 $ seq.len a
  return false

fn assert val msg:
  if not val:
    panic msg

let foreach = iter.foreach

let fold = iter.fold

let map = iter.map

let filter = iter.filter

let enumerate = iter.enumerate

let zip = iter.zip

let iterate = iter.iterate

fn yield a = iter.Yield a

fn sum s = fold s 0 add

fn extend s1 s2 = fold s2 s1 seq.append

fn max s:
  assert (seq.notempty? s) "sequence passed to min cannot be empty"
  fold s (fst s) do |acc x|:
    if lt? acc x:
      x
    else:
      acc

fn min s:
  assert (seq.notempty? s) "sequence passed to min cannot be empty"
  fold s (fst s) do |acc x|:
    if lt? x acc:
      x
    else:
      acc

fn apply f args = fold args f do |acc x| -> acc x

fn lazyapp f args = do -> apply f args

fn suspend comp:
  let called = false
  let ret = none
  do:
    if not called:
      ret = comp!
      called = true
    ret

fn exitblock body:
  effect Exit
  handle:
    ; wrap Exit effect in a function
    ; so it cannot be caught.
    body do a -> Exit a
  with Exit a:
    return a


extend prelude {
  scope,
  call,
  flip,
  const,
  const2,
  fst,
  snd,
  neq?,
  inc,
  dec,
  none?,
  zero?,
  assert,
  foreach,
  fold,
  sum,
  map,
  filter,
  iterate,
  extend,
  enumerate,
  zip,
  max,
  min,
  apply,
  lazyapp,
  suspend,
  io,
  seq,
  conv,
  time,
  http,
  inspect,
  records,
  exitblock,
}