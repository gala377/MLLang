fn scope b = b!

fn flip f a b = f b a

fn const a b = a

let const2 = flip const

fn fst s = seq.get s 0

fn snd s = seq.get s 1

fn neq? a b = not (eq? a b)

let none? = eq? none

let zero? = eq? 0

fn extend s1 s2 = fold s2 s1 seq.append

fn foreach s body:
  let i = 0
  let len = seq.len s
  while lt? i len:
    body (seq.get s i)
    i = add i 1

fn fold s init body:
  foreach s do x:
    init = body init x
  init

fn sum s = fold s 0 add

fn map s body:
  fold s [] do |acc x|:
    seq.append acc (body x)

fn filter s pred:
  fold s [] do |acc x|:
    if pred x:
      seq.append acc x
    acc

fn enumerate s:
  snd (fold s (0, []) do |acc x|:
    (add (fst acc) 1, seq.append (snd acc) (fst acc, x)))

fn zip s1 s2:
  if neq? (seq.len s1) (seq.len s2):
    panic "only sequences of equal lenght can be zipped"
  fold (enumerate s1) [] do |acc x|:
    seq.append acc (snd x, seq.get s2 (fst x))

fn max s:
  if zero? (seq.len s):
    panic "sequence passed to max cannot be empty"
  fold s (fst s) do |acc x|:
    if lt? acc x:
      x
    else:
      acc

fn min s:
  if zero? (seq.len s):
    panic "sequence passed to max cannot be empty"
  fold s (fst s) do |acc x|:
    if lt? x acc:
      x
    else:
      acc

fn apply f args = fold args f do |acc x| -> acc x

fn lazyapp f args = do -> apply f args
