effect Yield


let cf = scope:
  ; local effects so that they can only be handled by
  ; match and case handlers and cannot be intercepted
  ; by user handlers
  effect CF_CheckMatch
  effect CF_CheckCond

  ; match and patterns
  fn matchPattern pat val:
    if not $ function? pat:
      pat = if not $ seq? pat:
        let eqPattern = do v a:
          if eq? a v:
            return (v,)
        eqPattern pat
      else:
        let seqPattern = do patterns a:
          if not $ eq? (seq.len patterns) (seq.len a):
            return none
          let ret = map (zip patterns a) $ apply matchPattern
          if seq.or $ map ret none?:
            return none
          seq.concat ret
        seqPattern pat
    pat val

  fn match arg body:
    handle:
      body!
    with CF_CheckMatch req -> resumek:
      let pat = fst req
      let cbody = snd req
      let mres = matchPattern pat arg
      if none? mres:
        match arg do -> resumek none
      else:
        if neq? (seq.len mres) $ inspect.arity cbody:
          panic "Arity mismatched"
        apply cbody mres

  fn any a = (a,)

  fn pattern patf body = CF_CheckMatch (patf, body)

  ; condition
  fn condition body:
    let executed = false
    let ret = handle:
      body!
    with CF_CheckCond f:
      executed = true
      f!
    if not executed:
      panic "no matching condition arm"
    ret

  fn check pred body:
    if pred:
      CF_CheckCond body

  fn default body = ExecCond body

  ; iterators
  fn iterate s = do -> foreach s Yield

  fn collect acc it:
    handle:
      it!
    with Yield val -> resumek:
      seq.append acc val
      collect acc do -> resumek none
    acc

  fn map it body:
    do:
      handle:
        it!
      with Yield val -> resumek:
        Yield (body val)
        call $ map (do -> resumek none) body

  fn enumerate it:
    fn loop c it:
      handle:
        it!
      with Yield val -> resumek:
        Yield (c, val)
        loop (inc c) do -> resumek none
    do -> loop 0 it

  fn filter it pred = do:
    handle:
      it!
    with Yield val -> resumek:
      if pred val:
        Yield val
      call $ filter (do -> resumek none) pred

  fn zip it1 it2:
    let callIt1 = none
    let callIt2 = none

    callIt1 = do it1 it2:
      handle:
        it1!
      with Yield a -> resumek:
        callIt2 (do -> resumek none) it2 a

    callIt2 = do it1 it2 val:
      handle:
        it2!
      with Yield a -> resumek:
        Yield (val, a)
        callIt1 it1 do -> resumek none

    do -> callIt1 it1 it2

  fn take n it = do:
    if zero? n:
      return none
    handle:
      it!
    with Yield a -> resumek:
      Yield a
      call $ take (sub n 1) do -> resumek none

  fn numbers:
    fn loop v:
      Yield v
      loop $ inc v
    loop 0

  fn skip n it:
    if zero? n:
      return it
    do:
      handle:
       it!
      with Yield a -> resumek:
        call $ skip (sub n 1) do -> resumek none

  fn foreach it body:
    handle:
      it!
    with Yield a -> resumek:
      body a
      foreach (do -> resumek none) body

  fn inspect body it = do:
    handle:
      it!
    with Yield a -> resumek:
      body a
      Yield a
      call $ inspect body do -> resumek none

  {
    ; match and patterns
    match, pattern, any,
    ; condition
    condition, check, default,
    ; iterators
    iterate, collect, map, enumerate, filter, zip,
    take, skip, numbers, foreach, inspect,
  }

