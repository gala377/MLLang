effect Yield


let cf = scope:
  ; local effects so that they can only be handled by
  ; match and case handlers and cannot be intercepted
  ; by user handlers
  effect CF_CheckMatch
  effect CF_CheckCond

  ; match and patterns
  fn matchPattern pat val:
    if not $ function? pat:
      pat = if not $ seq? pat:
        let eqPattern = do v a:
          if eq? a v:
            return (v,)
        eqPattern pat
      else:
        let seqPattern = do patterns a:
          if not $ eq? (seq.len patterns) (seq.len a):
            return none
          let ret = map (zip patterns a) $ apply matchPattern
          if seq.or $ map ret none?:
            return none
          seq.concat ret
        seqPattern pat
    pat val

  fn match arg body:
    handle:
      body!
    with CF_CheckMatch req -> k:
      let pat = fst req
      let cbody = snd req
      let mres = matchPattern pat arg
      if none? mres:
        resume k
      else:
        if neq? (seq.len mres) $ inspect.arity cbody:
          panic "Arity mismatched"
        apply cbody mres

  fn any a = (a,)

  fn pattern patf body = CF_CheckMatch (patf, body)

  ; condition
  fn condition body:
    let executed = false
    let ret = handle:
      body!
    with CF_CheckCond f:
      executed = true
      f!
    if not executed:
      panic "no matching condition arm"
    ret

  fn check pred body:
    if pred:
      CF_CheckCond body

  fn default body = ExecCond body

  ; iterators
  fn iterate s = do -> foreach s Yield

  fn collect acc it:
    handle:
      it!
    with Yield val -> k:
      seq.append acc val
      resume k
    acc

  fn map it body:
    do:
      handle:
        it!
      with Yield val -> k:
        Yield (body val)
        resume k

  fn enumerate it = do:
    let curr = 0
    handle:
      it!
    with Yield val -> k:
      Yield (curr, val)
      curr = inc curr
      resume k

  fn filter it pred = do:
    handle:
      it!
    with Yield val -> k:
      if pred val:
        Yield val
      resume k

  fn zip it1 it2:
    let callIt1 = none
    let callIt2 = none

    callIt1 = do it1 it2:
      handle:
        it1!
      with Yield a -> resumek:
        callIt2 (do -> resumek none) it2 a

    callIt2 = do it1 it2 val:
      handle:
        it2!
      with Yield a -> resumek:
        Yield (val, a)
        callIt1 it1 do -> resumek none

    do -> callIt1 it1 it2

  fn take n it = do:
    handle:
      it!
    with Yield a -> k:
      if zero? n:
        return none
      Yield a
      n = dec n
      resume k

  fn numbers:
    let v = 0
    while true:
      Yield v
      v = inc v

  fn skip n it = do:
    handle:
     it!
    with Yield a -> k:
      if zero? n:
        Yield a
      else:
        n = dec n
      resume k

  fn foreach it body:
    handle:
      it!
    with Yield a -> k:
      body a
      resume k

  fn inspect body it = do:
    handle:
      it!
    with Yield a -> k:
      body a
      Yield a
      resume k

  effect Exit

  fn tagged? tag val:
    if pair? val:
      return eq? tag $ fst val
    return false

  fn exitblock body:
    let tag = gensym!
    handle:
      body do a -> Exit (tag, a)
    with Exit a if tagged? tag:
      return snd a

  {
    ; match and patterns
    match, pattern, any,
    ; condition
    condition, check, default,
    ; iterators
    iterate, collect, map, enumerate, filter, zip,
    take, skip, numbers, foreach, inspect,
    ; other
    exitblock,
  }

